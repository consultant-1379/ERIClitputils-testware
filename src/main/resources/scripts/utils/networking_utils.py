"""
Networking Utils

Note: :synopsis: for this file is located in source_code_docs.rst
"""

from litp_generic_utils import GenericUtils
from redhat_cmd_utils import RHCmdUtils
from netaddr import iter_iprange
from test_constants import RH_VERSION_6, RH_VERSION_6_10, \
    RH_VERSION_7, RH_VERSION_7_4, SLES_VERSION_15_4
import socket


class NetworkingUtils(object):

    """Networking commands related utilities.
    """

    def __init__(self):
        """Initialise networking variables.
        """
        self.g_util = GenericUtils()
        self.rhc = RHCmdUtils()
        self.dict_key_nic_name = "NAME"
        self.dict_key_lt = "ENCAP"
        self.dict_key_mac = "MAC"
        self.dict_key_ipv4 = "IPV4"
        self.dict_key_ipv6 = "IPV6"
        self.dict_key_bcast = "BCAST"
        self.dict_key_mask = "MASK"
        self.dict_key_rxp = "RXP"
        self.dict_key_txp = "TXP"
        self.route_path = "/sbin/route"
        self.ip_path = "/sbin/ip"
        self.arp_path = "/sbin/arp"

    def get_clear_ip_cmd(self, ip_to_clear, nic_name, alias_name=None,
                         ip6=False):
        """
        Get a command to clear the specified ipaddress from
        the specified device on the node.

        Args:
            ip_to_clear  (str): The ipaddress/subnet-bits to
                be cleared from the node.

            nic_name  (str): The device from which the
                ipaddress is to be cleared (e.g. 'eth1').

        Kwargs:
            alias_name  (str): Optional property if you wish to remove IP
                alias (virtual subinterface) of the specified device.

            ip6  (bool): If set to True, clears the ipv6 IP.

        Returns:
            str. The IP clear command.
        """
        if not ip6:
            if alias_name:
                return "{0} add delete {1} dev {2}:{3}".format(self.ip_path,
                                                               ip_to_clear,
                                                               nic_name,
                                                               alias_name)
            else:
                return "{0} add delete {1} dev {2}".format(self.ip_path,
                                                           ip_to_clear,
                                                           nic_name)
        else:
            if alias_name:
                return "{0} -6 add delete {1} dev {2}:{3}".format(self.ip_path,
                                                                  ip_to_clear,
                                                                  nic_name,
                                                                  alias_name)
            else:
                return "{0} -6 add delete {1} dev {2}".format(self.ip_path,
                                                              ip_to_clear,
                                                              nic_name)

    def get_arp_cmd(self, args=''):
        """
        Returns the arp command with supplied arguments.

        Kwargs:
            args (str): Optional arguments to pass to the arp command.

        Returns:
            str. The arp command as a string.
        """
        return "{0} {1}".format(self.arp_path, args)

    @staticmethod
    def get_allowed_ips(start_ip, end_ip):
        """
        Gets a list of all IPs in a given range.

        Args:
            start_ip (str): The start IP in an IP range.

            end_ip (str): The end IP in an IP range.

        Return:
            list. All allowed IPs in this range.
        """
        allowed_ips = list()

        ip_range = list(iter_iprange(start_ip, end_ip))

        for ip_item in ip_range:
            allowed_ips.append(str(ip_item))

        return allowed_ips

    def get_route_cmd(self, args=''):
        """
        Get the network route command.

        Args:
            args (str): Arguments to pass to the route command.

        Returns:
            str. The route cmd with specified arguments.
        """
        return "{0} {1}".format(self.route_path, args)

    def get_route_gw_ips_cmd(self):
        """
        Returns a command which prints out all available gateway IPs.

        Returns.
           str. "/sbin/route -n | /bin/grep 'UG[ ]' | /bin/awk '{print $2}'"
        """
        return \
            self.get_route_cmd("-n | /bin/grep 'UG[ \t]' " +\
                               "| /bin/awk '{print $2}'")

    def compare_nic_dicts(self, nic_dict1, nic_dict2):
        """Takes as arguments two nic dictionaries and checks that
        they are identical. Excludes Transmit and Receive keys.

        Args:
           nic_dict1 (dict): A nic dictionary generated by the get_ifcfg_dict\
              function.

           nic_dict2 (dict): A nic dictionary generated by the get_ifcfg_dict\
              function.

        Returns:
            bool. True if the dictionaries match or False otherwise.
        """

        for key in nic_dict1.keys():
            # Do not compare the Tx and Rx values as these are liable to change
            if key == self.dict_key_rxp or key == self.dict_key_txp:
                continue
            # Return False if any key is not equal
            if nic_dict1[key] != nic_dict2[key]:
                self.g_util.log("error", "NIC details do not match: {0}/{1}"\
                                    .format(nic_dict1[key], nic_dict2[key]))
                return False

        # Return True if all values have been proved to match
        return True

    @staticmethod
    def get_ifconfig_cmd(interface='', ifc_args=''):
        """Returns the command required to list the networking interface
        information on a node.

        Kwargs:
            interface  (str): Optional network interface.

            ifc_args   (str): Optional arguments for the network interfaces.

        Returns:
           str. String representing the command to retrieve the
           network interface information for a node.
        """

        if ifc_args != '':
            return '/sbin/ifconfig {0} {1}'.format(ifc_args, interface)

        return '/sbin/ifconfig {0}'.format(interface)

    @staticmethod
    def get_ping_cmd(ipaddr, count='1', args=''):
        """Returns the ping command as a string.

        Args:
            ipaddr  (str): A string IP address for the node to be pinged.

        Kwargs:
            count   (str): Optional count parameter for ping requests -
            Default is 1.

            args: Optional arguments to append to the ping command.

        Returns:
            str. The ping command as a string.
        """
        if args != '':
            args = '{0}'.format(args)

        ping_cmd = '/bin/ping -c {0} -W 5 {1} {2}'.format(count, ipaddr, args)

        return ping_cmd

    @staticmethod
    def get_ping6_cmd(ipaddr, count='1', args=''):
        """
        Returns the ping6 command as a string.

        Args:
            ipaddr  (str): A string IP address for the node to be pinged.

       Kwargs:
            count   (str): Optional count parameter for ping requests -
            Default is 1.

            args    (str): Optional arguments to pass to the ping6 command.

        Returns:
            str. The ping6 command.
        """
        if args != '':
            args = '{0}'.format(args)

        ping_cmd = '/bin/ping6 -c {0} {1} {2}'.format(count, ipaddr, args)

        return ping_cmd

    def get_node_nic_interfaces_cmd(self, active_only=False):
        """Returns a command which gets a list of all nics available on
        a given node.

        Kwargs:
            active_only (bool): If set to True, only
                returns active nics. Default is False.

        Returns:
            str. Command which uses ifconfig and sed to
            get all available nics excluding lo.
        """
        if active_only:
            ifcfg_cmd = self.get_ifconfig_cmd()
        else:
            ifcfg_cmd = self.get_ifconfig_cmd(ifc_args="-a")
        ##We ignore bond0 - LITPCDS-6422
        return ifcfg_cmd + " | grep 'flags=' | awk 'BEGIN{FS=\" \"} " \
                           "{print substr($0, 1, length($1)-1)}' | " \
                           "grep -v -E 'br|lo|vnet|bond0'"

    def ping_ip_from_local(self, ipaddr, count='1', retry=0):
        """Will ping the IP address provided for a given node from the
        machine where the test is being run from.

        Args:
            ipaddr  (str): A string IP address for the node to be pinged.

            count   (str): Optional count parameter for ping requests -
            Default is 1.

            retry   (int): Number of retry connections - Default is 0.

        Returns:
           bool. True if the IP address of the node is pingable or False
           if it is not.
        """

        if count == '' or count == '0':
            msg = 'A ping request count must be at least 1'
            self.g_util.log('error', msg)
            return False

        if retry == 0:
            retry += 1

        while retry > 0:
            ping_cmd = '/bin/ping -c {0} {1}'.format(count, ipaddr)
            retn = "{0} packets transmitted, {0} received, 0% packet loss"\
                .format(count)

            stdout, _, exit_code = self.g_util.run_command_local(ping_cmd)

            if exit_code == 0:
                for outp in stdout:
                    if retn in outp:
                        return True

            retry -= 1

        return False

    def get_cat_etc_hosts_cmd(self):
        """Returns the command required to view the
        contents of the hosts file on a node.

        Returns:
            str. String representing the command used to retrieve
            the contents of the /etc/hosts file on a node.
        """

        return self.rhc.get_cat_cmd('/etc/hosts')

    def _filter_ifcfg_output(self, output, nic_filter):
        """
        Takes as input the output of ifcfg and strips
        any nics in the text above the filter nic.

        Args:
          output (str): The ifconfig output.

          nic_filter (str): The nic you wish to filter by.

        Returns:
            list. The ifconfig output filtered or None if
            the filter nic is not found.
        """
        if nic_filter in "".join(output):

            line_count = 0
            for line in output:
                if nic_filter in line:
                    return output[line_count:]

                line_count += 1

        self.g_util.log("error",
                        "nic '{0}' not present in ifconfig"\
                            .format(nic_filter))
        return None

    def get_ifcfg_dict(self, output, nic_filter, os_ver=RH_VERSION_7):
        """Returns a dictionary structure of the fields contained within the
        output of the ifconfig command for the nic name given as nic filter.

        Args:
           output    (list): Output from running the ifconfig command.

           nic_filter (str): nic name to filter by (e.g. 'eth1').

           os_ver (str): Red Hat version tailed from /etc/redhat-release, by
                        default its RedHat 6 but the user can now check with
                        RedHat 7. SLES OS version from /etc/os-release.

        Returns:
           dict. ifconfig values or None if filter_nic is not present.
        """

        link_type = None
        mac_addr = None
        ipv4 = None
        ipv6 = None
        bcast = None
        mask = None
        rx_packets = None
        tx_packets = None

        output_part = self._filter_ifcfg_output(output, nic_filter)

        if not output_part:
            return None

        # We can have multi ipv6 addresses with different scopes
        ipv6_addresses = list()
        if RH_VERSION_6 in os_ver or RH_VERSION_6_10 in os_ver:
            for line in output_part:
                if "Link encap:" in line:
                    link_type = line.split("encap:")[1].split("  ")[0].strip()
                if "HWaddr" in line:
                    mac_addr = line.split("Waddr ")[1].strip()
                if "inet addr:" in line:
                    ipv4 = line.split("net addr:")[1].split("  ")[0].strip()
                if "Bcast:" in line:
                    bcast = line.split("Bcast:")[1].split("  ")[0].strip()
                if "Mask:" in line:
                    mask = line.split("Mask:")[1].strip()
                if "inet6 addr:" in line:
                    ipv6 = line.split("net6 addr: ")[1].split(
                        " Scope")[0].strip()
                    ipv6_addresses.append(ipv6)
                if "RX packets:" in line:
                    rx_packets = line.split("X packets:")[1].split()[0].strip()
                if "TX packets:" in line:
                    tx_packets = line.split("X packets:")[1].split()[0].strip()
                    # TX packets is the last entry in ifconfig output so we can
                    # break
                    break
        elif RH_VERSION_7 in os_ver or RH_VERSION_7_4 in os_ver or \
                SLES_VERSION_15_4 in os_ver:
            for line in output_part:
                if "(Ethernet)" in line:
                    link_type = line.split("(")[1].split(")")[0]
                if "ether " in line:
                    mac_addr = line.split("ether ")[1].strip(" ").split()[0]
                if "inet " in line:
                    ipv4 = line.split("inet")[1].split("  ")[0].strip()
                if "broadcast " in line:
                    bcast = line.split("broadcast")[1].split(" ")[1]
                if "netmask " in line:
                    mask = line.split("netmask")[1].split(" ")[1]
                if "inet6 " in line:
                    ipv6 = line.split("inet6 ")[1].split("  ")[0].strip()
                    if "prefixlen" in line:
                        ipv6 = ipv6 + "/" + \
                        line.split("prefixlen ")[1].split("  ")[0].strip()
                    ipv6_addresses.append(ipv6)
                if "RX packets " in line:
                    rx_packets = line.split("X packets")[1].split()[0].strip()
                if "TX packets " in line:
                    tx_packets = line.split("X packets")[1].split()[0].strip()
                    # TX packets is the last entry in ifconfig output so we can
                    # break
                    break
        ifcfg_dict = dict()
        ifcfg_dict[self.dict_key_nic_name] = nic_filter
        ifcfg_dict[self.dict_key_lt] = link_type
        ifcfg_dict[self.dict_key_mac] = mac_addr
        ifcfg_dict[self.dict_key_ipv4] = ipv4
        ifcfg_dict[self.dict_key_ipv6] = ipv6_addresses
        ifcfg_dict[self.dict_key_bcast] = bcast
        ifcfg_dict[self.dict_key_mask] = mask
        ifcfg_dict[self.dict_key_rxp] = rx_packets
        ifcfg_dict[self.dict_key_txp] = tx_packets

        return ifcfg_dict

    def get_lt_from_dict(self, ifcfg_dict):
        """Returns the link type from the
        dict created by calling get_ifcfg_dict.

        Args:
            ifcfg_dict (dict): The dict created by calling get_ifcfg_dict.

        Returns:
            str. The link type from the passed dictionary.
       """
        return ifcfg_dict[self.dict_key_lt]

    def get_mac_from_dict(self, ifcfg_dict):
        """Returns the MAC address from the
        dict created by calling get_ifcfg_dict.

        Args:
            ifcfg_dict (dict): The dict created by calling get_ifcfg_dict.

        Returns:
            str. The MAC address from the passed dictionary.
       """
        return ifcfg_dict[self.dict_key_mac]

    def get_ipv4_from_dict(self, ifcfg_dict):
        """Returns the ipv4 from the dict created by
        calling get_ifcfg_dict.

        Args:
           ifcfg_dict (dict): The dict created by calling get_ifcfg_dict.

        Returns:
            str. The ipv4 value.
       """
        return ifcfg_dict[self.dict_key_ipv4]

    def get_ipv6_from_dict(self, ifcfg_dict):
        """Returns the ipv6 from the dict created by
        calling get_ifcfg_dict.

        Args:
            ifcfg_dict (dict): The dict created by calling get_ifcfg_dict.

        Returns:
            str. The ipv6 value.
       """
        return ifcfg_dict[self.dict_key_ipv6]

    def get_bcast_from_dict(self, ifcfg_dict):
        """Returns the Bcast value from the dict created by
        calling get_ifcfg_dict.

        Args:
            ifcfg_dict (dict): The dict created by calling get_ifcfg_dict.

        Returns:
            str. The Bcast value.
       """
        return ifcfg_dict[self.dict_key_bcast]

    def get_mask_from_dict(self, ifcfg_dict):
        """Returns the mask value from the dict created by
        calling get_ifcfg_dict.

        Args:
            ifcfg_dict (dict): The dict created by calling get_ifcfg_dict.

        Returns:
            str. The mask value.
       """
        return ifcfg_dict[self.dict_key_mask]

    def get_rxp_from_dict(self, ifcfg_dict):
        """Returns receive packets total from the dict created by
        calling get_ifcfg_dict.

        Args:
           ifcfg_dict (dict): The dict created by calling get_ifcfg_dict.

        Returns:
            int. The receive packets total.
       """
        return ifcfg_dict[self.dict_key_rxp]

    def get_txp_from_dict(self, ifcfg_dict):
        """Returns the transmit packets total from the dict created by
        calling get_ifcfg_dict.

        Args:
           ifcfg_dict (dict): The dict created by calling get_ifcfg_dict.

        Returns:
            int. The transmit packets total.
       """
        return ifcfg_dict[self.dict_key_txp]

    def is_ip_in_range(self, selected_ip, ip_range_start,
                       ip_range_end):
        """
        Checks whether the passed IP is within the passed range.

        Args:
           selected_ip (str): The IP address to check.

           ip_range_start (str): The first IP in the range.

           ip_range_end (str): The last IP in the range.

        Returns:
            bool. True if IP is within range, False otherwise.
        """
        # Split ips up to get last value
        ip_start_parts = ip_range_start.split(".")
        ip_start = int(ip_start_parts[len(ip_start_parts) - 1])

        ip_end_parts = ip_range_end.split(".")
        ip_end = int(ip_end_parts[len(ip_end_parts) - 1])

        ip_parts = selected_ip.split(".")
        select_ip = int(ip_parts[len(ip_parts) - 1])

        # If last part of ip is within range return True
        if select_ip >= ip_start and select_ip <= ip_end:
            return True
        else:
            self.g_util.log("info", "IP {0} is not in range"
                            .format(selected_ip))
            return False

    @staticmethod
    def is_ipv4_address(ip_address):
        """
        Description:
            Checks whether the passed IP is ipv4 address or not.

        Args:
            ip_address (str): The IP address to check.

        Returns:
            bool. True if IP is ipv4, False otherwise.
        """
        try:
            socket.inet_aton(ip_address)
            return True
        except socket.error:
            return False
